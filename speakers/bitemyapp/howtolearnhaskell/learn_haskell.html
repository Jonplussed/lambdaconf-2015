<!DOCTYPE html>
<head>
<meta charset="utf-8">
  <meta name="author" content="Chris Allen" />
  <title>Learn Haskell in less than five years</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
<style>
  html { background-color: black; }
  body { background-color: white; border-radius: 12px}
  /* A section is a slide. It's size is 800x600, and this will never change */
  section {
      font-family: Arial, serif;
      font-size: 20pt;
    }
  address, blockquote, dl, fieldset, form, h1, h2, h3, h4, h5, h6, hr, ol, p, pre, table, ul, dl { padding: 10px 20px 10px 20px; }
  h1, h2, h3 {
    text-align: center;
    margin: 10pt 10pt 20pt 10pt;
  }
  ul, ol {
    margin: 10px 10px 10px 50px;
  }
  section.titleslide h1 { margin-top: 200px; }
  h1.title { margin-top: 150px; }
  h1 { font-size: 180%; }
  h2 { font-size: 120%; }
  h3 { font-size: 100%; }
  q { quotes: "“" "”" "‘" "’"; }
  blockquote { font-style: italic }
  /* Figures are displayed full-page, with the caption on
     top of the image/video */
  figure {
    background-color: black;
  }
  figcaption {
    margin: 70px;
  }
  footer {
    position: absolute;
    bottom: 0;
    width: 100%;
    padding: 40px;
    text-align: right;
    background-color: #F3F4F8;
    border-top: 1px solid #CCC;
  }

  /* Transition effect */
  /* Feel free to change the transition effect for original
     animations. See here:
     https://developer.mozilla.org/en/CSS/CSS_transitions
     How to use CSS3 Transitions: */
  section {
      -moz-transition: left 400ms linear 0s;
      -webkit-transition: left 400ms linear 0s;
      -ms-transition: left 400ms linear 0s;
      transition: left 400ms linear 0s;
  }

  /* Before */
  section { left: -150%; }
  /* Now */
  section[aria-selected] { left: 0; }
  /* After */
  section[aria-selected] ~ section { left: +150%; }

  /* Incremental elements */

  /* By default, visible */
  .incremental > * { opacity: 1; }

  /* The current item */
  .incremental > *[aria-selected] { color: red; opacity: 1; }

  /* The items to-be-selected */
  .incremental > *[aria-selected] ~ * { opacity: 0.2; }
</style>
</head>
<body>
<section class="title">
  <h1 class="title">Learn Haskell in less than five years</h1>
  <h2 class="author">Chris Allen</h2>
  <h3 class="date">May 2015</h3>
</section>
<section id="some-of-you-are-about-to-find-out-if-this-talk-was-a-waste-of-time" class="slide level1">
<h1>Some of you are about to find out if this talk was a waste of time</h1>
<ul>
<li><p>I'm not going to teach you Haskell</p></li>
<li><p>I'm not going to teach you how to teach Haskell</p></li>
<li><p>I'm not going to convince you to learn Haskell</p></li>
<li><p>I am going to talk about some problems I and other independent learners ran into trying to learn Haskell. Some of these take-aways are applicable outside of Haskell or even programming.</p></li>
</ul>
</section>
<section id="it-took-me-a-long-time-to-learn-haskell" class="slide level1">
<h1>It took me a long time to learn Haskell</h1>
<ul>
<li><p>I kept skimming off the surface like a stone</p></li>
<li><p>It wasn't pretty like this picture</p></li>
</ul>
<figure>
<img src="stone_skimming.jpg" />
</figure>
</section>
<section id="frustrating" class="slide level1">
<h1>Frustrating</h1>
<ul>
<li><p>I kept getting frustrated and stuck.</p></li>
<li><p>I'd complete a tutorial or book, attempt a project, flounder, then quit again.</p></li>
</ul>
<p><img src="flounder_small.jpg" width="200" height="200" /> You start wondering how anybody learned Haskell if you do this long enough.</p>
</section>
<section id="i-eventually-made-it" class="slide level1">
<h1>I eventually made it</h1>
<ul>
<li><p>Mostly by working through exercises and working on my own projects</p></li>
<li><p>I spent <em>way</em> too much time bouncing between different resources before I was able to work on any projects</p></li>
</ul>
</section>
<section id="ive-been-learning-how-to-teach-haskell" class="slide level1">
<h1>I've been learning how to teach Haskell</h1>
<ul>
<li><p>Almost two years now that I've been spending a lot of my time teaching Haskell</p></li>
<li><p>In person tutorials, meetups, email, IRC, Skype, etc.</p></li>
<li><p>#haskell-beginners is up to ~250 users these days.</p></li>
<li><p>Some very experienced Haskell users are helping out in #haskell-beginners now as well.</p></li>
<li><p>https://github.com/bitemyapp/learnhaskell has been around for a year as of the 19th this month and has been translated into German, French, Spanish, Italian, and Portuguese by community volunteers.</p></li>
</ul>
</section>
<section id="my-recommendations-for-what-to-use-to-learn-haskell" class="slide level1">
<h1>My recommendations for what to use to learn Haskell</h1>
<ul>
<li><p>cis194 (Spring '13), followed by NICTA Course.</p></li>
<li><p>Both are recommendations I got from other people. I didn't discover them myself.</p></li>
<li><p>I read them and tested them before changing the guide.</p></li>
<li><p>Everything in the guide is subject to getting removed/modified/replaced based on what we (myself and the other people helping out in #haskell-beginners) see people having problems with</p></li>
</ul>
</section>
<section id="limitations-when-helping-people-via-the-internet" class="slide level1">
<h1>Limitations when helping people via the internet</h1>
<ul>
<li><p>There is no control group</p></li>
<li><p>Still have <code>n &gt; 1</code> working in our favor</p></li>
<li><p>Lot to learn from professors, grad students, TAs teaching classes, but the audience is very different</p></li>
<li><p>Some are uni students, but <em>many</em> are self-taught programmers with little/no formal background in CS</p></li>
</ul>
</section>
<section id="show-dont-tell-is-a-good-start-but..." class="slide level1">
<h1>'Show, don't tell' is a good start, but...</h1>
<ul>
<li><p>&quot;Here's some code, it does stuff&quot; is appropriate (and quite useful) in library documentation but isn't a vehicle for comprehension <em>by itself</em></p></li>
<li><p>The learner has to synthesize as well as observe. Ideally the synthesis is iterated - they can change things as it follows a theme.</p></li>
<li><p>What if I do it with case? Guards? If-then-else?</p></li>
</ul>
</section>
<section id="having-learnt-something-doesnt-mean-you-can-teach-it" class="slide level1">
<h1>Having learnt something doesn't mean you can teach it</h1>
<ul>
<li><p>Usually it means you have a self-mythologized sample-size of 1.</p></li>
<li><p>Often people won't remember what parts they got stuck on or how they overcome those issues, remembering only the &quot;main track&quot; (book, tutorial, course) they were following <em>when</em> they got stuck.</p></li>
</ul>
</section>
<section id="fetish-and-myth" class="slide level1">
<h1>Fetish and Myth</h1>
<ul>
<li><p>Common anti-pattern: experienced (Haskellers | Programmers | etc.) recommending resources they didn't actually use to learn the topic.</p></li>
<li><p>CLRS is recommended by a lot more people than have done at least 10% of the book.</p></li>
<li><p>Going to call shenanigans on MacLane's Algebra too, unless you read it while in grad school for mathematics. You need a strong foundation before it will do you any good.</p></li>
</ul>
</section>
<section id="fetish-and-myth-1" class="slide level1">
<h1>Fetish and Myth</h1>
<ul>
<li><p>They're recommending resources to which they assign high prestige (difficulty, obscurity, etc.)</p></li>
<li><p>Then a beginner attempts to learn using an expert's Flavor of the Month, gets stuck, and burns out</p></li>
<li><p>You are not doing learners a favor when you do this</p></li>
<li><p>That resource is probably not how you learned the topic</p></li>
</ul>
</section>
<section id="you-have-to-get-off-the-happy-path" class="slide level1">
<h1>You have to get off the happy path</h1>
<ul>
<li><p>At least some of the time.</p></li>
<li><p>Try to anticipate what kind of errors they will encounter.</p></li>
</ul>
</section>
<section id="the-guide-i-put-together-has-some-limitations" class="slide level1">
<h1>The guide I put together has some limitations</h1>
<ul>
<li><p>I only know what people get stuck on if they ask for help from me directly or from others generally in the IRC channel</p></li>
<li><p>It's optimized around minimizing the rate at which people drop-out/get stuck. This means there are individual exceptions to the rule that can't be accounted for.</p></li>
<li><p>Also, some of the worst materials for learning Haskell are also the most well known, so I have to actively work to steer people away from those.</p></li>
</ul>
</section>
<section id="repetition-reinforcement" class="slide level1">
<h1>Repetition, reinforcement</h1>
<ul>
<li><p>Most resources have essentially one explanation per concept.</p></li>
<li><p>This is...not generally enough. Good exercises will highlight multiple facets of a single concept.</p></li>
<li><p>Let's see why this is a problem and include confusion, misunderstanding, or blocking (drop out or stuck) as our failure modes.</p></li>
</ul>
</section>
<section id="repetition-reinforcement-1" class="slide level1">
<h1>Repetition, reinforcement</h1>
<ul>
<li><p>Haskell isn't a one-trick pony. If you're learning Haskell, (almost) no matter what programming languages you already know, you are going to learn at least a handful of new concepts that don't have a strong connection with something you already know.</p></li>
<li><p>Most resources don't use anything close to an &quot;known effective&quot; explanation for each concept, but let's pretend the top-ranked explanation for each has an 80% success rate.</p></li>
</ul>
</section>
<section id="how-many-can-succeed-without-direct-intervention" class="slide level1">
<h1>How many can succeed without direct intervention?</h1>
<ul>
<li>This is a reduced linearization of learning Haskell and doesn't precisely capture how I teach</li>
</ul>
<p>Constants -&gt; Variables -&gt; Functions -&gt; Types -&gt; <br><br> Typeclasses -&gt; Products/Sums -&gt; <br><br> Type Constructors -&gt; Kinds</p>
</section>
<section id="how-many-can-succeed-without-direct-intervention-1" class="slide level1">
<h1>How many can succeed without direct intervention?</h1>
<ul>
<li>Now let's suppose we have somehow miraculously chosen the known-best explanations/examples/exercises for each concept that works for 80% of the cohort</li>
</ul>
<p>Constants (80%) -&gt; Variables (80%) -&gt; Functions (80%) -&gt; <br><br> Types (80%) -&gt; Typeclasses (80%) -&gt; Products/Sums (80%) -&gt; <br><br> Type Constructors (80%) -&gt; Kinds (80%)</p>
</section>
<section id="what-happened-to-our-cohort" class="slide level1">
<h1>What happened to our cohort?</h1>
<ul>
<li><p>We haven't gotten to Functor yet and we're down to 16% of our cohort.</p></li>
<li><p>Things usually get worse with Functor/Applicative/Monad. Many of the Haskell resources out there don't cover these at all, those that do either don't have proper exercises or have prose that provides zero explanatory power.</p></li>
</ul>
<!-- make a comment about appealing to the Sun God Ra and how it would be better for the reader because at least they'd know what you were telling them wasn't going to do them any good -->
</section>
<section id="functorapplicativemonad" class="slide level1">
<h1>Functor/Applicative/Monad</h1>
<ul>
<li><p>NICTA Course excels here but needs the bootstrap for the basics from cis194, especially for self-learners that don't have a tutor on hand.</p></li>
<li><p>You <em>have</em> to test the exercises and explanations and figure out multiple angles and approaches for explaining things.</p></li>
<li><p>cis194 and NICTA course are relatively well tested and the latter is updated based on teaching experience regularly.</p></li>
</ul>
</section>
<section id="what-do-you-need-to-understand-to-understand-functor" class="slide level1">
<h1>What do you need to understand to understand Functor?</h1>
<p>(in Haskell)</p>
<ul>
<li><p>Data constructors, type constructors (and kinds), functions, function composition, sum types, product type</p></li>
<li><p>I'm probably forgetting something here.</p></li>
</ul>
</section>
<section id="what-do-you-need-to-understand-to-use-functor" class="slide level1">
<h1>What do you need to understand to use Functor?</h1>
<ul>
<li><p>Handwave -&gt; Functor f =&gt; (map, []) ~ (fmap, f)</p></li>
<li><p>This is dangerous if this is all you tell them but it's not a bad bootstrap</p></li>
</ul>
</section>
<section id="why-is-the-handwave-problematic" class="slide level1">
<h1>Why is the handwave problematic?</h1>
<ul>
<li>Container?</li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Const</span> a b <span class="fu">=</span> <span class="dt">Const</span> a

<span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Const</span> a) <span class="kw">where</span>
    fmap f (<span class="dt">Const</span> x) <span class="fu">=</span> <span class="dt">Const</span> x</code></pre>
<ul>
<li>There's no &quot;container of b&quot; here despite what the type of <code>fmap</code> would seem to imply. <code>Const</code> has no <em>witness</em> to there being a value of type b because b is phantom.</li>
</ul>
</section>
<section id="why-is-the-handwave-problematic-1" class="slide level1">
<h1>Why is the handwave problematic?</h1>
<ul>
<li><p>Equating Functor with collections/containers will deprive the reader of understanding how Haskell actually works.</p></li>
<li><p>Examples aren't enough for Functor either.</p></li>
<li><p>Stick to the facts, use exercises to build intuitions. Don't stop at facile approximations.</p></li>
</ul>
</section>
<section id="what-do-you-need-to-do-to-learn-functor" class="slide level1">
<h1>What do you need to do to learn Functor?</h1>
<ul>
<li><p>Category theory provides different (but valuable) insight. Not a first-stop for learning Functor <em>as it exists in Haskell</em></p></li>
<li><p>Examples that work</p></li>
<li><p>Examples that don't work</p></li>
<li><p>Examples they need to fix</p></li>
<li><p>Write lots of Functor instances for datatypes</p></li>
<li><p>Write lots of code that commends the use of <code>fmap</code></p></li>
</ul>
</section>
<section id="how-to-learn" class="slide level1">
<h1>How to learn</h1>
<ul>
<li><p>Learning is something you <em>do</em>, not something that happens to you after reading a paragraph of text</p></li>
<li><p>You can't just read, you have to <em>work</em></p></li>
<li><p>Watch Kmett's talk, &quot;Stop Treading Water: Learning to Learn&quot;</p></li>
</ul>
</section>
<section id="interested-in-seeing-how-i-teach-haskell" class="slide level1">
<h1>Interested in seeing how I teach Haskell?</h1>
<ul>
<li><p>Julie (https://twitter.com/argumatronic) and I are working on a book</p></li>
<li><p>We've been targeting and testing with non-programmers on the assumption that if the material is sufficiently comprehensive for them, it should work as well or better for anybody that already codes.</p></li>
<li><p>http://haskellbook.com/ is available for early access now</p></li>
</ul>
</section>
<section id="got-questions" class="slide level1">
<h1>Got questions?</h1>
<ul>
<li>Now's the time :)</li>
</ul>
</section>
<!-- {{{{ dzslides core
#
#
#     __  __  __       .  __   ___  __
#    |  \  / /__` |    | |  \ |__  /__`
#    |__/ /_ .__/ |___ | |__/ |___ .__/ core :€
#
#
# The following block of code is not supposed to be edited.
# But if you want to change the behavior of these slides,
# feel free to hack it!
#
-->

<div id="progress-bar"></div>

<!-- Default Style -->
<style>
  * { margin: 0; padding: 0; -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box; }
  details { display: none; }
  body {
    width: 800px; height: 600px;
    margin-left: -400px; margin-top: -300px;
    position: absolute; top: 50%; left: 50%;
    overflow: hidden;
  }
  section {
    position: absolute;
    pointer-events: none;
    width: 100%; height: 100%;
  }
  section[aria-selected] { pointer-events: auto; }
  html { overflow: hidden; }
  body { display: none; }
  body.loaded { display: block; }
  .incremental {visibility: hidden; }
  .incremental[active] {visibility: visible; }
  #progress-bar{
    bottom: 0;
    position: absolute;
    -moz-transition: width 400ms linear 0s;
    -webkit-transition: width 400ms linear 0s;
    -ms-transition: width 400ms linear 0s;
    transition: width 400ms linear 0s;
  }
  figure {
    width: 100%;
    height: 100%;
  }
  figure > * {
    position: absolute;
  }
  figure > img, figure > video {
    width: 100%; height: 100%;
  }
</style>

<script>
  var Dz = {
    remoteWindows: [],
    idx: -1,
    step: 0,
    slides: null,
    progressBar : null,
    params: {
      autoplay: "1"
    }
  };

  Dz.init = function() {
    document.body.className = "loaded";
    this.slides = $$("body > section");
    this.progressBar = $("#progress-bar");
    this.setupParams();
    this.onhashchange();
    this.setupTouchEvents();
    this.onresize();
  }
  
  Dz.setupParams = function() {
    var p = window.location.search.substr(1).split('&');
    p.forEach(function(e, i, a) {
      var keyVal = e.split('=');
      Dz.params[keyVal[0]] = decodeURIComponent(keyVal[1]);
    });
  // Specific params handling
    if (!+this.params.autoplay)
      $$.forEach($$("video"), function(v){ v.controls = true });
  }

  Dz.onkeydown = function(aEvent) {
    // Don't intercept keyboard shortcuts
    if (aEvent.altKey
      || aEvent.ctrlKey
      || aEvent.metaKey
      || aEvent.shiftKey) {
      return;
    }
    if ( aEvent.keyCode == 37 // left arrow
      || aEvent.keyCode == 38 // up arrow
      || aEvent.keyCode == 33 // page up
    ) {
      aEvent.preventDefault();
      this.back();
    }
    if ( aEvent.keyCode == 39 // right arrow
      || aEvent.keyCode == 40 // down arrow
      || aEvent.keyCode == 34 // page down
    ) {
      aEvent.preventDefault();
      this.forward();
    }
    if (aEvent.keyCode == 35) { // end
      aEvent.preventDefault();
      this.goEnd();
    }
    if (aEvent.keyCode == 36) { // home
      aEvent.preventDefault();
      this.goStart();
    }
    if (aEvent.keyCode == 32) { // space
      aEvent.preventDefault();
      this.toggleContent();
    }
    if (aEvent.keyCode == 70) { // f
      aEvent.preventDefault();
      this.goFullscreen();
    }
  }

  /* Touch Events */

  Dz.setupTouchEvents = function() {
    var orgX, newX;
    var tracking = false;

    var db = document.body;
    db.addEventListener("touchstart", start.bind(this), false);
    db.addEventListener("touchmove", move.bind(this), false);

    function start(aEvent) {
      aEvent.preventDefault();
      tracking = true;
      orgX = aEvent.changedTouches[0].pageX;
    }

    function move(aEvent) {
      if (!tracking) return;
      newX = aEvent.changedTouches[0].pageX;
      if (orgX - newX > 100) {
        tracking = false;
        this.forward();
      } else {
        if (orgX - newX < -100) {
          tracking = false;
          this.back();
        }
      }
    }
  }

  /* Adapt the size of the slides to the window */

  Dz.onresize = function() {
    var db = document.body;
    var sx = db.clientWidth / window.innerWidth;
    var sy = db.clientHeight / window.innerHeight;
    var transform = "scale(" + (1/Math.max(sx, sy)) + ")";

    db.style.MozTransform = transform;
    db.style.WebkitTransform = transform;
    db.style.OTransform = transform;
    db.style.msTransform = transform;
    db.style.transform = transform;
  }


  Dz.getDetails = function(aIdx) {
    var s = $("section:nth-of-type(" + aIdx + ")");
    var d = s.$("details");
    return d ? d.innerHTML : "";
  }

  Dz.onmessage = function(aEvent) {
    var argv = aEvent.data.split(" "), argc = argv.length;
    argv.forEach(function(e, i, a) { a[i] = decodeURIComponent(e) });
    var win = aEvent.source;
    if (argv[0] === "REGISTER" && argc === 1) {
      this.remoteWindows.push(win);
      this.postMsg(win, "REGISTERED", document.title, this.slides.length);
      this.postMsg(win, "CURSOR", this.idx + "." + this.step);
      return;
    }
    if (argv[0] === "BACK" && argc === 1)
      this.back();
    if (argv[0] === "FORWARD" && argc === 1)
      this.forward();
    if (argv[0] === "START" && argc === 1)
      this.goStart();
    if (argv[0] === "END" && argc === 1)
      this.goEnd();
    if (argv[0] === "TOGGLE_CONTENT" && argc === 1)
      this.toggleContent();
    if (argv[0] === "SET_CURSOR" && argc === 2)
      window.location.hash = "#" + argv[1];
    if (argv[0] === "GET_CURSOR" && argc === 1)
      this.postMsg(win, "CURSOR", this.idx + "." + this.step);
    if (argv[0] === "GET_NOTES" && argc === 1)
      this.postMsg(win, "NOTES", this.getDetails(this.idx));
  }

  Dz.toggleContent = function() {
    // If a Video is present in this new slide, play it.
    // If a Video is present in the previous slide, stop it.
    var s = $("section[aria-selected]");
    if (s) {
      var video = s.$("video");
      if (video) {
        if (video.ended || video.paused) {
          video.play();
        } else {
          video.pause();
        }
      }
    }
  }

  Dz.setCursor = function(aIdx, aStep) {
    // If the user change the slide number in the URL bar, jump
    // to this slide.
    aStep = (aStep != 0 && typeof aStep !== "undefined") ? "." + aStep : ".0";
    window.location.hash = "#" + aIdx + aStep;
  }

  Dz.onhashchange = function() {
    var cursor = window.location.hash.split("#"),
        newidx = 1,
        newstep = 0;
    if (cursor.length == 2) {
      newidx = ~~cursor[1].split(".")[0];
      newstep = ~~cursor[1].split(".")[1];
      if (newstep > Dz.slides[newidx - 1].$$('.incremental > *').length) {
        newstep = 0;
        newidx++;
      }
    }
    this.setProgress(newidx, newstep);
    if (newidx != this.idx) {
      this.setSlide(newidx);
    }
    if (newstep != this.step) {
      this.setIncremental(newstep);
    }
    for (var i = 0; i < this.remoteWindows.length; i++) {
      this.postMsg(this.remoteWindows[i], "CURSOR", this.idx + "." + this.step);
    }
  }

  Dz.back = function() {
    if (this.idx == 1 && this.step == 0) {
      return;
    }
    if (this.step == 0) {
      this.setCursor(this.idx - 1,
                     this.slides[this.idx - 2].$$('.incremental > *').length);
    } else {
      this.setCursor(this.idx, this.step - 1);
    }
  }

  Dz.forward = function() {
    if (this.idx >= this.slides.length &&
        this.step >= this.slides[this.idx - 1].$$('.incremental > *').length) {
        return;
    }
    if (this.step >= this.slides[this.idx - 1].$$('.incremental > *').length) {
      this.setCursor(this.idx + 1, 0);
    } else {
      this.setCursor(this.idx, this.step + 1);
    }
  }

  Dz.goStart = function() {
    this.setCursor(1, 0);
  }

  Dz.goEnd = function() {
    var lastIdx = this.slides.length;
    var lastStep = this.slides[lastIdx - 1].$$('.incremental > *').length;
    this.setCursor(lastIdx, lastStep);
  }

  Dz.setSlide = function(aIdx) {
    this.idx = aIdx;
    var old = $("section[aria-selected]");
    var next = $("section:nth-of-type("+ this.idx +")");
    if (old) {
      old.removeAttribute("aria-selected");
      var video = old.$("video");
      if (video) {
        video.pause();
      }
    }
    if (next) {
      next.setAttribute("aria-selected", "true");
      var video = next.$("video");
      if (video && !!+this.params.autoplay) {
        video.play();
      }
    } else {
      // That should not happen
      this.idx = -1;
      // console.warn("Slide doesn't exist.");
    }
  }

  Dz.setIncremental = function(aStep) {
    this.step = aStep;
    var old = this.slides[this.idx - 1].$('.incremental > *[aria-selected]');
    if (old) {
      old.removeAttribute('aria-selected');
    }
    var incrementals = $$('.incremental');
    if (this.step <= 0) {
      $$.forEach(incrementals, function(aNode) {
        aNode.removeAttribute('active');
      });
      return;
    }
    var next = this.slides[this.idx - 1].$$('.incremental > *')[this.step - 1];
    if (next) {
      next.setAttribute('aria-selected', true);
      next.parentNode.setAttribute('active', true);
      var found = false;
      $$.forEach(incrementals, function(aNode) {
        if (aNode != next.parentNode)
          if (found)
            aNode.removeAttribute('active');
          else
            aNode.setAttribute('active', true);
        else
          found = true;
      });
    } else {
      setCursor(this.idx, 0);
    }
    return next;
  }

  Dz.goFullscreen = function() {
    var html = $('html'),
        requestFullscreen = html.requestFullscreen || html.requestFullScreen || html.mozRequestFullScreen || html.webkitRequestFullScreen;
    if (requestFullscreen) {
      requestFullscreen.apply(html);
    }
  }
  
  Dz.setProgress = function(aIdx, aStep) {
    var slide = $("section:nth-of-type("+ aIdx +")");
    if (!slide)
      return;
    var steps = slide.$$('.incremental > *').length + 1,
        slideSize = 100 / (this.slides.length - 1),
        stepSize = slideSize / steps;
    this.progressBar.style.width = ((aIdx - 1) * slideSize + aStep * stepSize) + '%';
  }
  
  Dz.postMsg = function(aWin, aMsg) { // [arg0, [arg1...]]
    aMsg = [aMsg];
    for (var i = 2; i < arguments.length; i++)
      aMsg.push(encodeURIComponent(arguments[i]));
    aWin.postMessage(aMsg.join(" "), "*");
  }
  
  function init() {
    Dz.init();
    window.onkeydown = Dz.onkeydown.bind(Dz);
    window.onresize = Dz.onresize.bind(Dz);
    window.onhashchange = Dz.onhashchange.bind(Dz);
    window.onmessage = Dz.onmessage.bind(Dz);
  }

  window.onload = init;
</script>


<script> // Helpers
  if (!Function.prototype.bind) {
    Function.prototype.bind = function (oThis) {

      // closest thing possible to the ECMAScript 5 internal IsCallable
      // function 
      if (typeof this !== "function")
      throw new TypeError(
        "Function.prototype.bind - what is trying to be fBound is not callable"
      );

      var aArgs = Array.prototype.slice.call(arguments, 1),
          fToBind = this,
          fNOP = function () {},
          fBound = function () {
            return fToBind.apply( this instanceof fNOP ? this : oThis || window,
                   aArgs.concat(Array.prototype.slice.call(arguments)));
          };

      fNOP.prototype = this.prototype;
      fBound.prototype = new fNOP();

      return fBound;
    };
  }

  var $ = (HTMLElement.prototype.$ = function(aQuery) {
    return this.querySelector(aQuery);
  }).bind(document);

  var $$ = (HTMLElement.prototype.$$ = function(aQuery) {
    return this.querySelectorAll(aQuery);
  }).bind(document);

  $$.forEach = function(nodeList, fun) {
    Array.prototype.forEach.call(nodeList, fun);
  }

</script>
<!-- vim: set fdm=marker: }}} -->
</body>
</html>
